FEATURE: Fast License Check (CLI & Library)

BUSINESS CONTEXT:
Open-source maintainers and enterprise DevOps teams need to ensure compliance 
by verifying that every source file in a repository contains a valid license header.
Manual verification is impossible at scale. Existing tools are often slow, 
hard to configure, or do not respect .gitignore rules effectively.
We need a "blazing fast," zero-config-by-default tool to enforce this in CI pipelines.

USER PERSONAS:
1. The Maintainer: Runs the tool locally before committing to ensure hygiene.
2. The DevOps Engineer: Runs the tool in GitHub Actions/GitLab CI to block non-compliant PRs.
3. The Compliance Officer: Needs a guarantee that 100% of code artifacts carry legal notices.

CORE USE CASES:
1. Scan Mode: Recursively scan a directory, report files missing headers, and exit with a non-zero code if failures found.
2. Fix Mode: Automatically prepend the correct license header to files missing it.
3. Git-Awareness: Automatically ignore files listed in .gitignore to avoid false positives.
4. Custom Configuration: Allow users to specify different license headers per file extension (e.g., // for Rust, # for Python).
5. Validation: Report files that have *malformed* or outdated headers.

BUSINESS RULES & INVARIANTS:
1. Safety First: The tool must NEVER corrupt binary files (images, executables, lockfiles).
2. Shebang Preservation: If a file starts with `#!` (shebang), the license header must be inserted *after* the shebang, or the script will break.
3. Idempotency: Running "Fix Mode" twice must not result in duplicate headers.
4. Respect Boundaries: Must strictly respect .gitignore and .ignore files.
5. Exit Codes: 
   - 0 = All clean / Fixes applied successfully.
   - 1 = Missing headers found (in Scan mode) or errors encountered.

CONSTRAINTS:
1. Performance: Must scan 100,000 files in under 1 second (warm cache) on standard hardware.
2. Parallelism: Must utilize all available CPU cores for file walking and string matching (Rayon/Tokio).
3. Distribution: Single static binary (no dependencies on Python/Node/JVM).
4. Memory: Low memory footprint (stream files, do not load entire repo into RAM).

EDGE CASES TO HANDLE:
1. File is empty (0 bytes) -> Skip or Warn (configurable).
2. File has a shebang (`#!/bin/bash`) -> Insert header at line 2.
3. File has an XML declaration (`<?xml ...`) -> Insert header at line 2.
4. File is UTF-16 or binary -> Skip detection automatically.
5. Partial header match -> If the header is 90% similar but slightly wrong, flag for review (do not auto-fix).
6. Very large files -> Stop scanning after the first N bytes (header checks shouldn't read a 1GB log file).

NON-GOALS (v1):
1. License Compatibility Check: We do not check if GPL is compatible with MIT.
2. Fetching licenses from internet: Users must provide the license text locally or via config.
3. OCR: We will not scan text inside images.

TECHNICAL PREFERENCES (Architecture):
1. Use `ignore` crate (from ripgrep) for file walking (performance standard).
2. Use `rayon` for parallel processing of file content.
3. Use `clap` for the CLI interface.
4. Use `thiserror` for library errors and `anyhow` for the CLI bin.
5. Zero-allocation parsing where possible (use byte slices).
6. Modular Monolith structure (core logic in `lib`, CLI adapter in `bin`).